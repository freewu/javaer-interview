## 分布式ID生成方案

| 方案      | 优点                                                         | 缺点                                                         |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| uuid      | 1  降低全局节点的压力,生成速度快<br/>2  生成的主键全局唯一<br/>3 跨服务器合并数据方便 | 1 占用16个字符,空间占用较多<br/>2 不是递增有序的数据字       |
| DB自增ID  | 1 int / bigint 类型占用空间小<br/>2 自动增长，IO写入连续性好<br/>3 数字类型查询速度优于字符串 | 1 并发性能不高，受限DB性能<br/>2 分库分表,需要改造<br/>3 自增，容易数据泄漏 |
| Redis自增 | 1 内存存储,并发性能好                                        | 1 数据丢失                                                   |
| snowflake | 1 不依赖外部组件<br/>2 性能好                                | 1 时钟回拨                                                   |

## snowflake 算法 组成

```
符号位(1)
时间戳(41)
机器ID(10) 高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。
序列号(12) 一毫秒可以生成4095个ID
```

## 分布式锁方案

| Redis     | SETNX +　过期时间  &  watch Dog + 续期  / Redisson.getLock |
| --------- | ---------------------------------------------------------- |
| ZooKeeper | 临时节点  / 顺序节点                                       |
| DB        | 主键唯一索引                                               |

## 限流算法

```
# 计数器算法 
	指定时间周期内累加访问次数
	使用 redis 的 incr 原子自增 + 过期时间来实现 
	
# 滑动时间窗口算法 
	解决计数器算法临界值的问题，TCP网络通信协议中就采用滑动时间窗口算法来解决网络拥堵
	将计数器算法中的实际周期切分多个小的时间窗口,分别在每个小的时间窗口记录访问次数
	然后根据时间窗口往前滑动并删除过期的小时间窗口
	最终统计滑动范围内的小时间窗口的总请求数
	窗口划分越多，滑动窗口的滚动就是越平滑,限流的统计就越精确

# 漏桶限流算法
	漏桶容量 = 漏桶的流出速度 * 可接受的等待时长
	缺点瞬间大流量会触发限流
`
# 令牌桶限流算法
	增加一个大小固定的容器(令牌桶)
	系统以恒定的速率向令牌桶放入令牌
	客户端请求,需要先从令牌桶中拿到令牌,才有资格访问系统
	当令牌桶满的时候，再向令牌桶生成令牌时，令牌会被抛弃
```

## 线程池

```
```

